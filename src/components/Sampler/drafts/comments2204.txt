
// const playSample = (note: number) => {
//   if (audioElementRef.current) {
//     const thisVoice = audioElementRef.current.cloneNode(
//       true
//     ) as HTMLAudioElement;

//     thisVoice.preservesPitch = false;
//     thisVoice.playbackRate = 2 ** ((note - 60) / 12);

//     thisVoice.addEventListener('pause', onPause);
//     thisVoice.addEventListener('play', onPlay);

//     voicesRef.current.push(thisVoice);
//     //thisVoice.volume = 0;
//     thisVoice.play();
//     // $(thisVoice).animate({ volume: 1 }, fadeInTimeRef.current); // ATTACK
//   } else {
//     console.error('audioElementRef.current is null');
//   }
// };

// const [fadeInTime, setFadeInTime] = useState(50);
// const fadeInTimeRef = useRef(50);

// const [fadeOutTime, setFadeOutTime] = useState(50);
// const fadeOutTimeRef = useRef(50);

/*
  const [droppedUrlState, setDroppedUrlState] = useState<string>('');

  if (droppedAudioUrl !== droppedUrlState) {
    setDroppedUrlState(droppedAudioUrl);
    prepPlayback(droppedAudioUrl);
  }
*/

// const handleFadeInChange = (event: Event): void => {
//   const newFadeInTime = parseInt(event.target.value);
//   setFadeInTime(newFadeInTime);
//   fadeInTimeRef.current = newFadeInTime;
// };

// const handleFadeOutChange = (event) => {
//   const newFadeOutTime = parseInt(event.target.value);
//   setFadeOutTime(newFadeOutTime);
//   fadeOutTimeRef.current = newFadeOutTime;
// };

/*

  function onPlay(sample: HTMLAudioElement) {}

  function fadeOutSample(thisVoice) {
    setTimeout(() => {
      $(thisVoice).animate({ volume: 0 }, fadeOutTime); // RELEASE
    }, startFadeTime);

    setTimeout(() => {
      thisVoice.pause();
      voicesRef.current = voicesRef.current.filter((c) => c !== thisVoice); // n√≥g clean-up?
    }, endFadeTime);
  }
*/

// function prepPlayback(sampleUrl: string) {
//   if (audioElementRef.current) {
//     const ref = audioElementRef.current;
//     if (ref.src) {
//       URL.revokeObjectURL(ref.src);
//     }
//     ref.src = sampleUrl;

//     // wait for 'duration' metadata to be loaded
//     ref.onloadedmetadata = function () {
//       ref.preservesPitch = false;

//       // const durationMs = (ref.duration * 1000) / currentSample.playbackRate;
//       //const startFadeTime = durationMs / 2;
//       //const endFadeTime = startFadeTime + fadeOutTime;

//       //ref.addEventListener('play', onPlay);
//       ref.addEventListener('pause', onPause);

//       // fadeOutSample(thisVoice);
//     };
//   }
// }

{
  /*
        <label htmlFor="fadeInRange">Fade In: {fadeInTimeRef.current}</label>
        <input
          type="range"
          id="fadeInRange"
          name="fadeInRange"
          min="100"
          max="5000"
          step="100"
          value={fadeInTimeRef.current}
          onChange={handleFadeInChange}
        />

       <label htmlFor="fadeOutRange">Fade Out: {fadeOutTimeRef.current}</label>
        <input
          type="range"
          id="fadeOutRange"
          name="fadeOutRange"
          min="100"
          max="5000"
          step="100"
          value={fadeOutTimeRef.current}
          onChange={handleFadeOutChange}
      /> */
}
