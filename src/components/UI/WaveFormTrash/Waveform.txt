import React, { useRef, useEffect, useCallback, useState } from 'react';
import { Time_settings } from '../../../types/samples';
import SamplerEngine from '../../../lib/engine/SamplerEngine';

type settingKey = 'startPoint' | 'endPoint' | 'loopStart' | 'loopEnd';

type WaveformState = {
  sampleId: string;
  buffer: AudioBuffer;
  settings: Time_settings;
  normalizedSettings: Time_settings;
};

interface WaveformProps {
  width: number;
  height: number;
  color?: string;
  backgroundColor?: string;
  showCenterLine?: boolean;
}

const Waveform: React.FC<WaveformProps> = ({
  width,
  height,
  color = '#3498db',
  backgroundColor = 'transparent',
  showCenterLine = true,
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const pixelRatioRef = useRef(window.devicePixelRatio || 1);
  const MIN_MARKER_DISTANCE = 0.0008;

  const samplerEngine = SamplerEngine.getInstance();

  const [mouseStyle, setMouseStyle] = useState('default');
  const [currentState, setCurrentState] = useState<WaveformState>();

  // Convert time values to normalized values
  const normalizePoint = (point: number, buffer: AudioBuffer): number =>
    buffer.duration ? point / buffer.duration : 0;

  //  TODO: Make sure this effect gets triggered:
  // on mount
  // when a new sample is selected for settings
  // if Time settings are changed from outside the waveform component
  useEffect(() => {
    if (!samplerEngine) return;

    const selected = samplerEngine.getSelectedForSettings()[0]; // Modify if needed for multiple samples
    const buffer = samplerEngine.getBufferForSettings(selected);
    const settings = samplerEngine.getSampleSettings(
      selected,
      'Time'
    ) as Time_settings;

    console.log('Waveform: useEffect', selected, buffer, settings);

    if (
      !(
        selected &&
        buffer &&
        settings &&
        settings.startPoint &&
        settings.endPoint &&
        settings.loopStart &&
        settings.loopEnd
      )
    )
      return;

    const normalizedSettings = {
      startPoint: normalizePoint(settings.startPoint, buffer),
      endPoint: normalizePoint(settings.endPoint, buffer),
      loopStart: normalizePoint(settings.loopStart, buffer),
      loopEnd: normalizePoint(settings.loopEnd, buffer),
    };

    const newState: WaveformState = {
      sampleId: selected,
      buffer,
      settings: settings as Time_settings,
      normalizedSettings: normalizedSettings as Time_settings,
    };

    setCurrentState(newState);
  }, [samplerEngine]);

  const [dragState, setDragState] = useState<{
    type: 'marker' | 'label' | null;
    key: settingKey | null;
    offset: number;
  }>({ type: null, key: null, offset: 0 });

  const normalizeData = useCallback((data: Float32Array): Float32Array => {
    let maxVal = 0;
    for (let i = 0; i < data.length; i++) {
      const absVal = Math.abs(data[i]);
      if (absVal > maxVal) {
        maxVal = absVal;
      }
    }

    if (maxVal === 0) return data;

    const normalizedData = new Float32Array(data.length);
    for (let i = 0; i < data.length; i++) {
      normalizedData[i] = data[i] / maxVal;
    }

    return normalizedData;
  }, []);

  const getMarkerPixelPosition = useCallback(
    (markerValue: number) => {
      // Ensure markerValue is within [0, 1] range
      const clampedValue = Math.max(0, Math.min(1, markerValue));
      // Account for potential padding or borders
      const drawableWidth = width - 2; // Subtract 2 for left and right 1px borders
      return Math.round(clampedValue * drawableWidth) + 1; // Add 1 to account for left border
    },
    [width]
  );

  const drawMarker = useCallback(
    (markerValue: number, markerColor: string, label: string) => {
      if (!(currentState && currentState.buffer)) return; // No sample available

      const canvas = canvasRef.current;
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      const markerWidth = 2;
      const labelPadding = 5;
      const labelHeight = 20;
      const labelWidth = ctx.measureText(label).width + labelPadding * 2;

      const pixelX = Math.min(
        width - 1,
        Math.max(0, getMarkerPixelPosition(markerValue))
      );
      ctx.fillStyle = markerColor;
      ctx.fillRect(pixelX - markerWidth / 2, 0, markerWidth, height);

      ctx.fillStyle = 'transparent';
      ctx.fillRect(pixelX + labelPadding, 0, labelWidth, labelHeight);

      ctx.font = '12px Arial';
      ctx.fillStyle = markerColor;
      ctx.fillText(label, pixelX + labelPadding, 15);
    },
    [height, getMarkerPixelPosition, width]
  );

  const drawWaveform = useCallback(() => {
    const { sampleId, buffer, settings, normalizedSettings } =
      currentState ?? {};

    if (!(sampleId && buffer && settings && normalizedSettings)) return;

    const canvas = canvasRef.current;
    const ctx = canvas?.getContext('2d');

    if (!(canvas && ctx)) return;

    const pxr = pixelRatioRef.current;
    canvas.width = width * pxr;
    canvas.height = height * pxr;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;

    ctx.scale(pxr, pxr);
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(0, 0, width, height);

    const data = normalizeData(buffer.getChannelData(0));
    const step = Math.ceil(data.length / width);
    const amp = height / 2;

    ctx.beginPath();
    ctx.moveTo(0, amp);

    // const zoomedWidth = width * zoomValue;
    // const zoomOffset = loopStart ? loopStart * width * (1 - zoomValue) : 0;

    for (let i = 0; i < width; i++) {
      let min = 1.0;
      let max = -1.0;

      // const dataIndex = Math.floor((i + zoomOffset) / zoomValue);
      const dataIndex = i;
      for (let j = 0; j < step; j++) {
        const datum = data[dataIndex * step + j];
        if (datum < min) min = datum;
        if (datum > max) max = datum;
      }

      ctx.lineTo(i, (1 + min) * amp);
      ctx.lineTo(i, (1 + max) * amp);
    }

    ctx.strokeStyle = color;
    ctx.stroke();

    if (showCenterLine) {
      ctx.beginPath();
      ctx.moveTo(0, amp);
      ctx.lineTo(width, amp);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.stroke();
    }

    const {
      startPoint,
      endPoint,
      loopStart,
      loopEnd,
    } = // NOT NORMALIZED ?
      currentState?.settings as Time_settings;

    if (startPoint !== undefined) drawMarker(startPoint, 'red', 'Start');
    if (endPoint !== undefined) drawMarker(endPoint, 'red', 'End');
    if (loopStart !== undefined) drawMarker(loopStart, 'green', 'Loop-Start');
    if (loopEnd !== undefined) drawMarker(loopEnd, 'green', 'Loop-End');
  }, [
    currentState,
    currentState?.buffer, // needed?
    width,
    height,
    color,
    backgroundColor,
    showCenterLine,
    normalizeData,
    drawMarker,
  ]);

  const getMarkerAtPosition = useCallback(
    (
      x: number,
      y: number
    ): {
      type: 'marker' | 'label';
      key: settingKey;
    } | null => {
      if (!(currentState && currentState.settings)) return null;

      const { startPoint, endPoint, loopStart, loopEnd } =
        currentState.settings as Time_settings;

      const markers = [
        { key: 'startPoint' as settingKey, value: startPoint, label: 'Start' },
        { key: 'endPoint' as settingKey, value: endPoint, label: 'End' },
        {
          key: 'loopStart' as settingKey,
          value: loopStart,
          label: 'Loop-Start',
        },
        { key: 'loopEnd' as settingKey, value: loopEnd, label: 'Loop-End' },
      ];

      const ctx = canvasRef.current!.getContext('2d')!;
      ctx.font = '12px Arial';

      for (const marker of markers) {
        if (marker.value !== undefined) {
          const pixelX = getMarkerPixelPosition(marker.value);
          const labelWidth = ctx.measureText(marker.label).width + 10;
          const labelHeight = 20;

          if (
            x >= pixelX + 5 &&
            x <= pixelX + 5 + labelWidth &&
            y >= 0 &&
            y <= labelHeight
          ) {
            setMouseStyle('pointer');
            return { type: 'label', key: marker.key };
          }

          if (Math.abs(x - pixelX) < 5) {
            setMouseStyle('cursor');
            return { type: 'marker', key: marker.key };
          }
        }
      }
      setMouseStyle('default');
      return null;
    },
    [currentState, getMarkerPixelPosition]
  );

  const getMarkerValue = (key: string): number => {
    if (!(currentState && currentState.settings))
      throw new Error('No settings');

    const { startPoint, endPoint, loopStart, loopEnd } =
      currentState.settings as Time_settings;

    switch (key) {
      case 'startPoint':
        return startPoint || 0;
      case 'endPoint':
        return endPoint || 1;
      case 'loopStart':
        return loopStart || 0;
      case 'loopEnd':
        return loopEnd || 1;
      default:
        return 0;
    }
  };

  const handleDrag = useCallback(
    (x: number, dragType: 'marker' | 'label') => {
      if (!(dragState.key && currentState && currentState.settings)) return;

      const { startPoint, endPoint, loopStart, loopEnd } =
        currentState.settings as Time_settings;

      let newValue_normalized;
      if (dragType === 'label') {
        newValue_normalized = Math.max(
          0,
          Math.min(1, (x - dragState.offset) / width)
        );
      } else {
        newValue_normalized = Math.max(0, Math.min(1, x / width));
      }

      switch (dragState.key) {
        case 'startPoint':
          newValue_normalized = Math.min(
            newValue_normalized,
            (endPoint || 1) - MIN_MARKER_DISTANCE
          );
          break;
        case 'loopStart':
          newValue_normalized = Math.min(
            newValue_normalized,
            (loopEnd || 1) - MIN_MARKER_DISTANCE
          );
          break;
        case 'loopEnd':
          newValue_normalized = Math.max(
            newValue_normalized,
            (loopStart || 0) + MIN_MARKER_DISTANCE
          );
          break;
        case 'endPoint':
          newValue_normalized = Math.max(
            newValue_normalized,
            (startPoint || 0) + MIN_MARKER_DISTANCE
          );
          break;
      }

      const newValue_seconds =
        newValue_normalized * currentState.buffer.duration;

      const newSetting: Partial<Time_settings> = {
        [dragState.key]: newValue_seconds,
      };

      samplerEngine.updateTimeSettings(currentState.sampleId, newSetting);

      // Update local state to trigger re-render
      setCurrentState({
        ...currentState,
        settings: {
          ...currentState.settings,
          [dragState.key]: newValue_seconds,
        },
        normalizedSettings: {
          ...currentState.normalizedSettings,
          [dragState.key]: newValue_normalized,
        },
      });
    },
    [dragState, samplerEngine, width]
  );

  const handleMouseDown = useCallback(
    (e: React.MouseEvent<HTMLCanvasElement>) => {
      e.preventDefault();
      e.stopPropagation();

      const rect = canvasRef.current!.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * width;
      const y = e.clientY - rect.top;

      const hitResult = getMarkerAtPosition(x, y);
      if (hitResult) {
        const markerValue = getMarkerValue(hitResult.key);
        const markerX = getMarkerPixelPosition(markerValue);
        const offset = hitResult.type === 'label' ? x - markerX : 0;

        setDragState({
          type: hitResult.type,
          key: hitResult.key,
          offset: offset,
        });
      }
    },
    [getMarkerAtPosition, width, getMarkerPixelPosition]
  );

  const handleMouseMove = useCallback(
    (e: React.MouseEvent<HTMLCanvasElement>) => {
      const rect = canvasRef.current!.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * width;
      const y = e.clientY - rect.top;

      getMarkerAtPosition(x, y);

      if (!dragState.type) return;

      e.preventDefault();
      e.stopPropagation();

      setMouseStyle('grabbing');

      handleDrag(x, dragState.type);
    },
    [dragState, handleDrag, width, getMarkerAtPosition]
  );

  const handleMouseUp = useCallback(
    (e: React.MouseEvent<HTMLCanvasElement>) => {
      e.preventDefault();
      e.stopPropagation();

      setDragState({ type: null, key: null, offset: 0 });
      setMouseStyle('default');
    },
    []
  );

  useEffect(() => {
    drawWaveform();
  }, [drawWaveform]);

  return (
    <canvas
      ref={canvasRef}
      width={width}
      height={height}
      onMouseDown={handleMouseDown}
      onMouseMove={handleMouseMove}
      onMouseUp={handleMouseUp}
      onMouseLeave={handleMouseUp}
      style={{ cursor: mouseStyle }}
    />
  );
};

export default Waveform;

// import { useSampleSettings } from '../../../hooks/useSampleSettings';
// import { useZoom } from '../../../hooks/useZoom';

// Possibly add to state:
// add dynamic width and height?

// zoomValue: number;
// zoomOffset: number;
// zoomedWidth: number;
// loopDuration: number;
// playDuration: number;
// dragState: {
//   type: 'marker' | 'label' | null;
//   key: settingKey | null;
//   offset: number;
// };
// mouseStyle: string;

// const { handleSettingChange } = useSampleSettings();
// const { zoomValue, setZoom } = useZoom({ minZoom: 1, maxZoom: 10 });
// const [playDuration, setPlayDuration] = useState<number | null>(null);
// const [loopDuration, setLoopDuration] = useState<number | null>(null);

// from handleDrag:
// handleSettingChange(
//   dragState.key as keyof Sample_settings,
//   newValue_seconds
// );

// setPlayDuration(endPoint! - startPoint!);
// setLoopDuration(loopEnd! - loopStart!);

// useEffect(() => {
//   if (buffer && width > 0) {
//     calculateZoom();
//   }
// }, [loopStart, loopEnd, buffer, width, calculateZoom]);

// const calculateZoom = useCallback(() => {
//   if (loopStart === undefined || loopEnd === undefined) return;

//   const loopDuration = loopEnd - loopStart;
//   const fullDuration = buffer.duration;
//   const minZoom = width / (fullDuration * 200); // 200 pixels per second
//   const minZoomDuration = 0.015; // TODO: test for optimal value

//   if (loopDuration < minZoomDuration) {
//     const newZoom = Math.min(minZoomDuration / loopDuration, 10);
//     setZoom(Math.max(newZoom, minZoom));
//   } else if (loopDuration < fullDuration) {
//     const newZoom = Math.min(fullDuration / loopDuration, 10);
//     setZoom(Math.max(newZoom, minZoom));
//   } else {
//     setZoom(minZoom);
//   }
// }, [loopStart, loopEnd, buffer, width, setZoom]);

// const getMarkerPixelPosition = useCallback(
//   (markerValue: number) => {
//     // const zoomOffset = loopStart ? loopStart * width * (1 - zoomValue) : 0;
//     // return (markerValue * width - zoomOffset) * zoomValue;
//     return markerValue * width;
//   },
//   [width /*, zoomValue, loopStart*/]
// );
