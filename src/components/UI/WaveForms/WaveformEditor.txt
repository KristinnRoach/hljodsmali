import React, { useRef, useEffect, useState } from 'react';
import { useSamplerEngine } from '../../../contexts/EngineContext';

interface WaveformEditorProps {
  sampleId: string;
}

const WaveformEditor: React.FC<WaveformEditorProps> = ({ sampleId }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [isDragging, setIsDragging] = useState<string | null>(null);
  const { getSampleSettings, updateTimeSettings, getBufferDuration } =
    useSamplerEngine();

  const drawWaveform = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const settings = getSampleSettings(sampleId, 'Time');
    if (!settings) return;

    const { startPoint, endPoint, loopStart, loopEnd } = settings;
    const duration = getBufferDuration(sampleId);

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw waveform (simplified representation)
    ctx.beginPath();
    ctx.moveTo(0, canvas.height / 2);
    for (let i = 0; i < canvas.width; i++) {
      ctx.lineTo(
        i,
        (Math.sin(i * 0.1) * canvas.height) / 4 + canvas.height / 2
      );
    }
    ctx.stroke();

    // Draw markers
    const drawMarker = (position: number, color: string) => {
      const x = (position / duration) * canvas.width;
      ctx.fillStyle = color;
      ctx.fillRect(x - 2, 0, 4, canvas.height);
    };

    drawMarker(startPoint, 'green');
    drawMarker(endPoint, 'red');
    drawMarker(loopStart, 'blue');
    drawMarker(loopEnd, 'purple');
  };

  useEffect(() => {
    drawWaveform();
  }, [sampleId, getSampleSettings, getBufferDuration]);

  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const settings = getSampleSettings(sampleId, 'Time');
    if (!settings) return;

    const { startPoint, endPoint, loopStart, loopEnd } = settings;
    const duration = getBufferDuration(sampleId);
    const clickPosition = (x / canvas.width) * duration;

    // Determine which marker is being dragged (simplified logic)
    if (Math.abs(clickPosition - startPoint) < 0.1) setIsDragging('startPoint');
    else if (Math.abs(clickPosition - endPoint) < 0.1)
      setIsDragging('endPoint');
    else if (Math.abs(clickPosition - loopStart) < 0.1)
      setIsDragging('loopStart');
    else if (Math.abs(clickPosition - loopEnd) < 0.1) setIsDragging('loopEnd');
  };

  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDragging) return;

    const canvas = canvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const duration = getBufferDuration(sampleId);
    const newPosition = (x / canvas.width) * duration;

    updateTimeSettings(sampleId, { [isDragging]: newPosition });
    drawWaveform();
  };

  const handleMouseUp = () => {
    setIsDragging(null);
  };

  return (
    <canvas
      ref={canvasRef}
      width={800}
      height={200}
      onMouseDown={handleMouseDown}
      onMouseMove={handleMouseMove}
      onMouseUp={handleMouseUp}
      onMouseLeave={handleMouseUp}
    />
  );
};

export default WaveformEditor;
